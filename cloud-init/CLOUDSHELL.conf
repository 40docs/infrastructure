#cloud-config

timezone: America/Toronto
package_update: true
package_upgrade: true
package_reboot_if_required: true

power_state:
  delay: now
  mode: reboot
  message: Rebooting after cloud-init
  timeout: 30
  condition: true

bootcmd:
  - mkdir -p /home /var/lib/docker /root/.ollama
  - |
    format_and_mount() {
      local lun="$1" label="$2" mount_point="$3" always_format="$4"
      local dev="/dev/disk/azure/scsi1/lun$${lun}"
      local part="$${dev}-part1"

      for i in $(seq 1 30); do
        if [ -b "$dev" ]; then
          echo "[INFO] $dev detected."
          break
        fi
        sleep 2
      done

      if [ "$always_format" = "yes" ]; then
        # Check if the partition is currently mounted and unmount it
        if mount | grep -q "$part"; then
          echo "[INFO] $part is currently mounted, unmounting before format..."
          umount -f "$part" 2>/dev/null || true
        fi
        echo "[INFO] Formatting $dev (forced) for $mount_point ..."
        wipefs -a "$dev" 2>/dev/null || true  # Complete filesystem signature wipe
        parted -s "$dev" mklabel gpt mkpart primary ext4 0% 100%
        mkfs.ext4 -F "$part" -L "$label"
      else
        if ! blkid "$part" >/dev/null 2>&1; then
          echo "[INFO] No filesystem on $dev — formatting for $mount_point ..."
          parted -s "$dev" mklabel gpt mkpart primary ext4 0% 100%
          mkfs.ext4 -F "$part" -L "$label"
        else
          echo "[INFO] Filesystem already exists on $dev — preserving data."
        fi
      fi

      # Mount will be handled by the mounts: section
    }

    format_and_mount 0 homefs /home yes  # Always format home disk for clean state
    format_and_mount 1 dockerfs /var/lib/docker no
    format_and_mount 2 ollamafs /root/.ollama no

mounts:
  - [ "LABEL=homefs", "/home", "ext4", "defaults,nofail", "0", "2" ]
  - [ "LABEL=dockerfs", "/var/lib/docker", "ext4", "defaults,nofail", "0", "2" ]
  - [ "LABEL=ollamafs", "/root/.ollama", "ext4", "defaults,nofail", "0", "2" ]

ssh_deletekeys: false
ssh_keys:
  rsa_private: |
    ${indent(4, var_ssh_host_rsa_private)}
  rsa_public: |
    ${indent(4, var_ssh_host_rsa_public)}
  ecdsa_private: |
    ${indent(4, var_ssh_host_ecdsa_private)}
  ecdsa_public: |
    ${indent(4, var_ssh_host_ecdsa_public)}
  ed25519_private: |
    ${indent(4, var_ssh_host_ed25519_private)}
  ed25519_public: |
    ${indent(4, var_ssh_host_ed25519_public)}

apt:
  sources:
    authd:
      source: ppa:ubuntu-enterprise-desktop/authd
    dotnet:
      source: ppa:dotnet/backports
    ansible:
      source: ppa:ansible/ansible
%{ if var_has_gpu }    nvtop:
      source: ppa:quentiumyt/nvtop
    nvidia:
      source: ppa:graphics-drivers/ppa%{ endif }
    trivy:
      source: deb [arch=amd64 signed-by=$KEY_FILE] https://get.trivy.dev/deb generic main
      keyserver: https://get.trivy.dev/deb/public.key
      keyid: E9D0A3616276FA6C
    hashicorp:
      source: deb [arch=amd64 signed-by=$KEY_FILE] https://apt.releases.hashicorp.com $RELEASE main
      keyserver: https://apt.releases.hashicorp.com/gpg
      keyid: AA16FCBCA621E701
    github-cli:
      source: deb [arch=amd64 signed-by=$KEY_FILE] https://cli.github.com/packages stable main
      keyserver: https://cli.github.com/packages/githubcli-archive-keyring.gpg
      keyid: 23F3D4EA75716059
    google-cloud-sdk:
      source: deb [arch=amd64 signed-by=$KEY_FILE] http://packages.cloud.google.com/apt cloud-sdk main
      keyserver: https://packages.cloud.google.com/apt/doc/apt-key.gpg
      keyid: C0BA5CE6DC6315A3
    google-chrome:
      source: deb [arch=amd64 signed-by=$KEY_FILE] http://dl.google.com/linux/chrome/deb/ stable main
      keyserver: https://dl-ssl.google.com/linux/linux_signing_key.pub
      keyid: 7721F63BD38B4796
    docker:
      source: deb [arch=amd64 signed-by=$KEY_FILE] https://download.docker.com/linux/ubuntu noble stable
      keyserver: https://download.docker.com/linux/ubuntu/gpg
      keyid: 8D81803C0EBFCD88
%{ if var_has_gpu }    nvidia-container-toolkit:
      source: deb [arch=amd64 signed-by=$KEY_FILE] https://nvidia.github.io/libnvidia-container/stable/deb/$(ARCH) /
      keyserver: https://nvidia.github.io/libnvidia-container/gpgkey
      keyid: DDCAE044F796ECB0%{ endif }
    azure-cli:
      source: deb [arch=amd64 signed-by=$KEY_FILE] https://packages.microsoft.com/repos/azure-cli/ $RELEASE main
      keyserver: https://packages.microsoft.com/keys/microsoft.asc
      keyid: EB3E94ADBE1229CF
    vscode:
      source: deb [arch=amd64 signed-by=$KEY_FILE] https://packages.microsoft.com/repos/vscode stable main
      keyserver: https://packages.microsoft.com/keys/microsoft.asc
      keyid: EB3E94ADBE1229CF
    powershell:
      source: deb [arch=amd64 signed-by=$KEY_FILE] https://packages.microsoft.com/ubuntu/24.04/prod $RELEASE main
      keyserver: https://packages.microsoft.com/keys/microsoft.asc
      keyid: EB3E94ADBE1229CF
    ubuntu-universe:
      source: "deb http://archive.ubuntu.com/ubuntu $RELEASE universe"
    ubuntu-multiverse:
      source: "deb http://archive.ubuntu.com/ubuntu $RELEASE multiverse"

write_files:
  - path: /root/install-github-action-runner.sh
    permissions: '0755'
    owner: root:root
    content: |
      #!/bin/bash
      set -uo pipefail

      echo "[$(date)] Starting GitHub Actions runner installation script" | tee -a /var/log/cloud-init-output.log
      ORG_URL="https://github.com/${var_github_org}"
      GITHUB_TOKEN="${var_github_token}"
      RUNNER_GROUP="${var_runner_group}"
      RUNNER_LABELS="${var_runner_labels}"
      INSTALL_DIR="/opt/actions-runner"

      # Security: Ensure GitHub token is not logged
      secure_log() {
        local message="$1"
        # Remove any potential token exposure from log messages
        echo "$message" | sed 's/token [a-zA-Z0-9_-]*/token [REDACTED]/g' | tee -a /var/log/cloud-init-output.log
      }

      # Validate GitHub token is present
      if [ -z "$GITHUB_TOKEN" ] || [ "$GITHUB_TOKEN" = "null" ]; then
        secure_log "[$(date)] ERROR: GitHub token is missing or invalid"
        exit 1
      fi

      # Validate GitHub token has necessary permissions
      validate_github_token() {
        secure_log "[$(date)] Validating GitHub token permissions..."

        # Check if token can access the organization
        local org_response=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/orgs/${var_github_org}" 2>/dev/null)

        if [ $? -ne 0 ] || [ -z "$org_response" ]; then
          secure_log "[$(date)] ERROR: Cannot access GitHub organization ${var_github_org}"
          return 1
        fi

        # Check if token has admin:org permission (required for runners)
        local scopes_response=$(curl -s -I -H "Authorization: token $GITHUB_TOKEN" \
          "https://api.github.com/orgs/${var_github_org}/actions/runners" 2>/dev/null | grep -i "x-oauth-scopes:" || true)

        if [ -z "$scopes_response" ]; then
          secure_log "[$(date)] WARNING: Cannot determine token scopes, proceeding anyway"
        else
          secure_log "[$(date)] Token scopes detected: $scopes_response"
        fi

        secure_log "[$(date)] GitHub token validation completed"
        return 0
      }

      # Validate the GitHub token first
      if ! validate_github_token; then
        secure_log "[$(date)] FATAL: GitHub token validation failed"
        exit 1
      fi

      # Function to generate a fresh registration token using GitHub API
      generate_registration_token() {
        local max_attempts=5
        local attempt=1
        local wait_time=10

        secure_log "[$(date)] Generating fresh GitHub Actions registration token..."

        while [ $attempt -le $max_attempts ]; do
          secure_log "[$(date)] Attempt $attempt of $max_attempts to generate registration token"

          # Generate registration token using GitHub API
          local response=$(curl -s -X POST \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/orgs/${var_github_org}/actions/runners/registration-token" 2>/dev/null)

          if [ $? -eq 0 ] && [ -n "$response" ]; then
            # Extract token from JSON response
            REG_TOKEN=$(echo "$response" | jq -r '.token' 2>/dev/null)

            if [ "$REG_TOKEN" != "null" ] && [ -n "$REG_TOKEN" ] && [ "$REG_TOKEN" != "" ]; then
              secure_log "[$(date)] Successfully generated registration token"
              return 0
            else
              secure_log "[$(date)] Failed to parse registration token from response"
              # Log response but redact any potential tokens
              secure_log "[$(date)] API Response: $response"
            fi
          else
            secure_log "[$(date)] API request failed or returned empty response"
          fi

          if [ $attempt -lt $max_attempts ]; then
            secure_log "[$(date)] Waiting $wait_time seconds before retry..."
            sleep $wait_time
            wait_time=$((wait_time * 2))  # Exponential backoff
          fi
          attempt=$((attempt + 1))
        done

        secure_log "[$(date)] ERROR: Failed to generate registration token after $max_attempts attempts"
        return 1
      }

      # Generate the registration token
      if ! generate_registration_token; then
        secure_log "[$(date)] FATAL: Cannot proceed without registration token"
        exit 1
      fi

      if which curl | grep -q snap; then
        snap remove curl || true
        apt-get update && apt-get install -y curl
      fi

      if ! dpkg -l | grep -q libicu72; then
        echo "[$(date)] Attempting to install libicu72..." | tee -a /var/log/cloud-init-output.log
        ARCH=$(dpkg --print-architecture)
        if [ "$ARCH" = "amd64" ]; then
          LIBICU_URL="http://archive.ubuntu.com/ubuntu/pool/main/i/icu/libicu72_72.1-3ubuntu3_amd64.deb"
        elif [ "$ARCH" = "arm64" ]; then
          LIBICU_URL="http://ports.ubuntu.com/pool/main/i/icu/libicu72_72.1-3ubuntu3_arm64.deb"
        fi

        # Try downloading with retries and verification
        for attempt in 1 2 3; do
          echo "[$(date)] Download attempt $attempt for libicu72..." | tee -a /var/log/cloud-init-output.log
          if wget --timeout=30 --tries=3 "$LIBICU_URL" -O /tmp/libicu72.deb 2>/dev/null; then
            # Verify the download is complete
            if dpkg-deb --info /tmp/libicu72.deb >/dev/null 2>&1; then
              echo "[$(date)] libicu72 download successful" | tee -a /var/log/cloud-init-output.log
              dpkg -i /tmp/libicu72.deb || apt-get install -f -y
              rm -f /tmp/libicu72.deb
              break
            else
              echo "[$(date)] Downloaded file is corrupted, retrying..." | tee -a /var/log/cloud-init-output.log
              rm -f /tmp/libicu72.deb
            fi
          else
            echo "[$(date)] Download failed, attempt $attempt" | tee -a /var/log/cloud-init-output.log
          fi
          [ $attempt -lt 3 ] && sleep 5
        done

        # If all attempts failed, try installing from apt if available
        if ! dpkg -l | grep -q libicu72; then
          echo "[$(date)] All download attempts failed, trying apt-get install libicu74 as alternative" | tee -a /var/log/cloud-init-output.log
          apt-get update && apt-get install -y libicu74 || true
        fi
      fi

      TMPDIR="$(mktemp -d)"
      trap "rm -rf $TMPDIR" EXIT
      mkdir -p "$INSTALL_DIR" && cd "$TMPDIR"

      ASSET_URL="$(/usr/bin/curl -sL https://api.github.com/repos/actions/runner/releases/latest | awk -F '\"' '/browser_download_url/ && /linux-x64/ {print $4; exit}')"
      [ -z "$ASSET_URL" ] && {
        LATEST_TAG="$(/usr/bin/curl -sIL https://github.com/actions/runner/releases/latest | awk -F'[:/ ]' '/^location:/ {print $NF}' | tr -d '\r')"
        [ -n "$LATEST_TAG" ] && {
          VER="$(echo "$LATEST_TAG" | sed 's/^v//')"
          ASSET_URL="https://github.com/actions/runner/releases/download/$LATEST_TAG/actions-runner-linux-x64-$VER.tar.gz"
        }
      }

      [ -f "$INSTALL_DIR/svc.sh" ] && { "$INSTALL_DIR/svc.sh" stop || true; "$INSTALL_DIR/svc.sh" uninstall || true; }

      if [ -n "$ASSET_URL" ]; then
        echo "[$(date)] Downloading runner from $ASSET_URL" | tee -a /var/log/cloud-init-output.log
        /usr/bin/curl -LSso "$TMPDIR/runner.tgz" "$ASSET_URL" || echo "[$(date)] Runner download failed" | tee -a /var/log/cloud-init-output.log
      fi

      if [ -f "$TMPDIR/runner.tgz" ]; then
        echo "[$(date)] Extracting runner archive" | tee -a /var/log/cloud-init-output.log
        tar -C "$INSTALL_DIR" -xzf "$TMPDIR/runner.tgz" || echo "[$(date)] Runner extraction failed" | tee -a /var/log/cloud-init-output.log
      fi

      if [ -x "$INSTALL_DIR/bin/installdependencies.sh" ]; then
        echo "[$(date)] Installing runner dependencies" | tee -a /var/log/cloud-init-output.log
        "$INSTALL_DIR/bin/installdependencies.sh" || echo "[$(date)] Dependencies installation had issues" | tee -a /var/log/cloud-init-output.log
      fi

      if [ -x "$INSTALL_DIR/config.sh" ]; then
        secure_log "[$(date)] Configuring runner with fresh registration token"
        cd "$INSTALL_DIR"

        # Verify the registration token before using it
        if [ -z "$REG_TOKEN" ] || [ "$REG_TOKEN" = "null" ]; then
          secure_log "[$(date)] ERROR: Invalid registration token, cannot configure runner"
          exit 1
        fi

        # Configure the runner with retry logic
        config_attempts=3
        config_attempt=1

        while [ $config_attempt -le $config_attempts ]; do
          secure_log "[$(date)] Runner configuration attempt $config_attempt of $config_attempts"

          if RUNNER_ALLOW_RUNASROOT="1" ./config.sh --unattended --replace --url "$ORG_URL" --token "$REG_TOKEN" --runnergroup "$RUNNER_GROUP" --labels "$RUNNER_LABELS"; then
            secure_log "[$(date)] Runner configuration successful"
            break
          else
            secure_log "[$(date)] Runner configuration attempt $config_attempt failed"
            if [ $config_attempt -eq $config_attempts ]; then
              secure_log "[$(date)] ERROR: All runner configuration attempts failed"
              exit 1
            fi
            sleep 10
          fi
          config_attempt=$((config_attempt + 1))
        done
      else
        secure_log "[$(date)] Runner config.sh not found"
        exit 1
      fi

      if [ -x "$INSTALL_DIR/svc.sh" ]; then
        secure_log "[$(date)] Installing and starting runner service"
        cd "$INSTALL_DIR"
        if ./svc.sh install root; then
          secure_log "[$(date)] Service installation successful"
          if ./svc.sh start; then
            secure_log "[$(date)] Service start successful"
          else
            secure_log "[$(date)] Service start failed"
            exit 1
          fi
        else
          secure_log "[$(date)] Service installation failed"
          exit 1
        fi
      else
        secure_log "[$(date)] Runner svc.sh not found"
        exit 1
      fi

      secure_log "[$(date)] GitHub Actions runner installation script completed successfully"
  - path: /etc/ssh/sshd_config.d/custom.conf
    content: |
      UsePAM yes
      KbdInteractiveAuthentication yes
      PrintMotd no
      PrintLastLog no
      UseDNS no
  - path: /root/prewarm-cache.sh
    permissions: '0755'
    owner: root:root
    content: |
      #!/bin/bash
      set -uo pipefail

      # Enhanced logging function
      log_msg() {
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] PREWARM: $1" | tee -a /var/log/cloud-init-output.log
      }

      # Timeout wrapper function
      run_with_timeout() {
        local timeout_duration=$1
        local description=$2
        shift 2
        log_msg "Starting: $description (timeout: ${timeout_duration}s)"

        if timeout "$timeout_duration" "$@"; then
          log_msg "Completed successfully: $description"
          return 0
        else
          local exit_code=$?
          if [ $exit_code -eq 124 ]; then
            log_msg "TIMEOUT after ${timeout_duration}s: $description"
          else
            log_msg "FAILED with exit code $exit_code: $description"
          fi
          return $exit_code
        fi
      }

      log_msg "Starting VS Code cache pre-warming process"

      # Wait for VS Code with detailed logging
      log_msg "Waiting for VS Code installation to complete..."
      vscode_found=false
      for i in {1..30}; do
        if command -v code >/dev/null 2>&1; then
          log_msg "VS Code found after ${i} attempts ($(which code))"
          vscode_found=true
          break
        fi
        [ $((i % 10)) -eq 0 ] && log_msg "Still waiting for VS Code... attempt $i/30"
        sleep 2
      done

      if [ "$vscode_found" = false ]; then
        log_msg "VS Code not found after 60 seconds, skipping cache pre-warming"
        exit 0
      fi

      # Check for extensions.json file
      extensions_file="$HOME/40docs/.vscode/extensions.json"
      if [ ! -f "$extensions_file" ]; then
        log_msg "Extensions file not found: $extensions_file, skipping extension installation"
        exit 0
      fi

      log_msg "Found extensions file: $extensions_file"

      # Parse extensions with error handling
      if ! EXT_LIST=$(jq -r ".recommendations[]" "$extensions_file" 2>/dev/null); then
        log_msg "Failed to parse extensions file, skipping extension installation"
        exit 0
      fi

      ext_count=$(echo "$EXT_LIST" | wc -l)
      log_msg "Found $ext_count extensions to install"

      # Install extensions with timeouts and logging
      current_ext=0
      for EXT in $EXT_LIST; do
        current_ext=$((current_ext + 1))
        log_msg "Installing extension $current_ext/$ext_count: $EXT"

        # Install for regular VS Code with timeout
        if ! run_with_timeout 120 "VS Code extension $EXT" \
          code --install-extension "$EXT" --force \
               --user-data-dir "$HOME/.vscode-server/data" \
               --extensions-dir "$HOME/.vscode-server/extensions"; then
          log_msg "Failed to install $EXT for VS Code, continuing..."
        fi

        # Install for VS Code Insiders with timeout
        if command -v code-insiders >/dev/null 2>&1; then
          if ! run_with_timeout 120 "VS Code Insiders extension $EXT" \
            code-insiders --install-extension "$EXT" --force \
                         --user-data-dir "$HOME/.vscode-server-insiders/data" \
                         --extensions-dir "$HOME/.vscode-server-insiders/extensions"; then
            log_msg "Failed to install $EXT for VS Code Insiders, continuing..."
          fi
        fi
      done

      log_msg "Extension installation completed"

      # Pre-warm VS Code with timeout and logging
      if ! run_with_timeout 60 "VS Code cache pre-warming" \
        env DISPLAY="" code --no-sandbox \
                          --user-data-dir "$HOME/.vscode-server/data" \
                          --extensions-dir "$HOME/.vscode-server/extensions" \
                          --skip-welcome --skip-release-notes --disable-telemetry \
                          --version; then
        log_msg "VS Code pre-warming failed or timed out, continuing..."
      fi

      # Pre-warm VS Code Insiders with timeout
      if command -v code-insiders >/dev/null 2>&1; then
        if ! run_with_timeout 60 "VS Code Insiders cache pre-warming" \
          env DISPLAY="" code-insiders --no-sandbox \
                                      --user-data-dir "$HOME/.vscode-server-insiders/data" \
                                      --extensions-dir "$HOME/.vscode-server-insiders/extensions" \
                                      --skip-welcome --skip-release-notes --disable-telemetry \
                                      --version; then
          log_msg "VS Code Insiders pre-warming failed or timed out, continuing..."
        fi
      fi

      log_msg "VS Code cache pre-warming process completed successfully"
      exit 0
  - path: /etc/profile.d/nvm.sh
    owner: root:root
    permissions: '0644'
    content: |
      export NVM_DIR=/usr/local/nvm
      [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
      [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
  - path: /etc/profile.d/user-local-bin.sh
    owner: root:root
    permissions: '0644'
    content: |
      # Add ~/.local/bin to PATH for all users
      export PATH="$HOME/.local/bin:$PATH"
%{ if var_has_gpu }  - path: /etc/profile.d/nvidia.sh
    owner: root:root
    permissions: '0644'
    content: |
      # NVIDIA GPU environment variables
      export NVIDIA_VISIBLE_DEVICES=all
      export NVIDIA_DRIVER_CAPABILITIES=all
      export CUDA_VISIBLE_DEVICES=all%{ endif }
  - path: /root/.lacework.toml
    content: |
      [default]
        account = "${var_forticnapp_account}"
        subaccount = "${var_forticnapp_subaccount}"
        api_key = "${var_forticnapp_api_key}"
        api_secret = "${var_forticnapp_api_secret}"
        version = 2
  - path: /root/npm-install.sh
    permissions: '0755'
    owner: root:root
    content: |
      #!/bin/bash
      set -uo pipefail
      NVM_DIR="/usr/local/nvm"

      [[ ! -d "$${NVM_DIR}/.git" ]] && git clone -q https://github.com/nvm-sh/nvm.git "$${NVM_DIR}" || git -C "$${NVM_DIR}" pull -q || true
      [ -f "$${NVM_DIR}/nvm.sh" ] && . "$${NVM_DIR}/nvm.sh" || exit 0

      unset NPM_CONFIG_PREFIX
      export npm_config_prefix="" npm_config_globalconfig=""
      [[ -f "/root/.npmrc" ]] && mv /root/.npmrc "/root/.npmrc.bak"

      nvm install node --silent && nvm alias default node && nvm use default --delete-prefix --silent || exit 0
      nvm use --delete-prefix "v24.4.1" --silent 2>/dev/null || true
      npm config set loglevel error

      PACKAGES="@anaisbetts/mcp-installer @modelcontextprotocol/server-memory @modelcontextprotocol/server-filesystem @modelcontextprotocol/server-brave-search @modelcontextprotocol/server-sequential-thinking @azure/mcp@latest @21st-dev/magic@latest @qwen-code/qwen-code@latest bash-language-server claude-auto-commit cwebp @devcontainers/cli dockerfile-language-server-nodejs eslint eslint-config-prettier gatsby-cli javascript-typescript-langserver jsonlint markdownlint markdownlint-cli markdownlint-cli2 newman opal-security playwright prettier puppeteer setup-eslint-config sql-language-server stylelint-config-prettier svgo terminalizer unified-language-server vscode-css-languageserver-bin vscode-html-languageserver-bin vscode-json-languageserver-bin yaml-language-server"

      for PKG in $PACKAGES; do
        CXXFLAGS="--std=gnu++20" npm install -g --no-save "$PKG" >/dev/null 2>&1 || true
      done

      playwright install --with-deps chromium >/dev/null 2>&1 || true
      find / -maxdepth 1 -type f \( -name "=0.22" -o -name "=1.12" -o -name "=2.0" -o -name "'=0.22'" \) -delete 2>/dev/null || true
      exit 0

packages:
  - alsa-utils
  - apt-file
  - ansible
  - ansible-lint
  - apache2-utils
  - apparmor
  - apt-transport-https
  - asciidoctor
  - aspnetcore-runtime-9.0
  - autoconf
  - azure-cli
  - bash-completion
  - bat
  - build-essential
  - cabextract
  - ca-certificates
  - cockpit
  - code
  - code-insiders
  - cmake
  - curl
  - dos2unix
  - docker-ce
  - docker-ce-cli
  - containerd.io
  - docker-compose-plugin
  - docker-ce-rootless-extras
  - docker-buildx-plugin
  - dotnet-sdk-9.0
  - dotnet-sdk-8.0
  - dotnet-sdk-6.0
  - dpkg
  - dpkg-dev
  - dnsutils
  - ffmpeg
  - file
  - fontconfig
  - fonts-powerline
  - frei0r-plugins
  - fuse3
  - fzf
  - g++
  - gh
  - gnupg
  - golang-go
  - graphviz
  - gstreamer1.0-libav
  - gstreamer1.0-vaapi
  - gstreamer1.0-plugins-base
  - gstreamer1.0-plugins-good
  - gstreamer1.0-plugins-bad
  - gstreamer1.0-plugins-ugly
  - google-cloud-cli
  - google-chrome-stable
  - hwloc
  - imagemagick
  - inkscape
  - iputils-ping
  - kubectl
  - ladspa-sdk
  - libapache2-mod-php
  - libavif-dev
  - libc6
  - libfuse3-3
  - libgcc-s1
  - libgstreamer1.0-0
  - libicu74
  - liblttng-ust1t64
  - libappindicator3-1
  - libdbusmenu-glib4
  - libdbusmenu-gtk3-4
  - libfftw3-bin
  - libfftw3-dev
  - libfftw3-long3
  - libfftw3-quad3
  - libfftw3-single3
  - libfuse2t64
  - libgavl2
  - libgl1-mesa-dri
  - libgl1
  - libgif-dev
  - libglu1-mesa
  - libhwloc-dev
  - libhwloc15
  - libicu-dev
  - libmovit-dev
  #- libnvidia-container-tools
  #- libnvidia-container1
  #- libnvidia-encode1
  #- libnvcuvid1
  #- libnvidia-decode-575
  #- libnvidia-decode-575-server
  - libnotify4
  - libnuma-dev
  - libpoppler-cpp-dev
  - librust-gdk-pixbuf-sys-dev
  - libsecret-1-0
  - libsecret-1-dev
  - libsecret-common
  - libsox-fmt-all
  - libstdc++6
  - libssl3t64
  - libslirp0
  - libglx-mesa0
  - libunwind8
  - libvulkan1
  - libvidstab-dev
  - libyelp-dev
  - locales
  - locales-all
  - lsb-release
  - lsd
  - make
  - melt
  - mesa-utils
  - mesa-utils-bin
  - mesa-vulkan-drivers
  - mtr
  - nmap
  - npm
%{ if var_has_gpu }  - nvidia-driver-575
  - nvidia-container-toolkit
  - nvtop%{ endif }
  - php
  - php-cli
  - php-cgi
  - php-mysql
  - php-pgsql
  - pigz
  - pkexec
  - pkg-config
  - policykit-1
  - postgresql
  - postgresql-contrib
  - poppler-utils
  - powershell
  - python3-full
  - python3-pip
  - python3-venv
  - shellcheck
  - skopeo
  - slirp4netns
  - snapd
  - software-properties-common
  - squashfs-tools
  - swh-plugins
  - sox
  - sqlite3
  - terraform
  - tesseract-ocr
  - tini
  - tcpdump
  - tofrodos
  - trivy
  - ubuntu-drivers-common
  - unzip
  - vlc
  - vim-syntastic
  - weasyprint
  - xvfb
  - xdg-utils
  - yq
  - yamllint
  - yelp-tools
  - zsh
  - zlib1g

runcmd:
  - echo "runcmd executed at $(date)"
  - |
    DEBIAN_FRONTEND=noninteractive apt install authd -y
    snap install authd-msentraid
    systemctl stop authd authd.socket ssh systemd-logind ssh.socket
    snap stop authd-msentraid
    mkdir -p /etc/authd/brokers.d/
    chmod 700 /etc/authd
    chmod 700 /etc/authd/brokers.d
    cp /snap/authd-msentraid/current/conf/authd/msentraid.conf /etc/authd/brokers.d/msentraid.conf
    sed -i \
      -e 's|issuer = https://login.microsoftonline.com/<ISSUER_ID>/v2.0|issuer = "https://login.microsoftonline.com/${var_directory_tenant_id}/v2.0"|' \
      -e 's|client_id = <CLIENT_ID>|client_id = "${var_directory_client_id}"|' \
      /var/snap/authd-msentraid/current/broker.conf
    sed -i 's/^#allowed_users = OWNER$/allowed_users = ALL/' /var/snap/authd-msentraid/current/broker.conf
    echo 'ssh_allowed_suffixes = @fortinet-us.com' >> /var/snap/authd-msentraid/current/broker.conf
    rm -rf /var/lib/authd
    mkdir -p /var/lib/authd
    chmod 700 /var/lib/authd
    systemctl start authd
    timeout 10 bash -c 'until systemctl is-active --quiet authd; do sleep 0.5; done' || echo "authd not yet active, proceeding..."
    snap start authd-msentraid
    systemctl start ssh systemd-logind ssh.socket
  - |
    systemctl stop systemd-logind || true
    systemctl stop getty@tty1.service || true
    umount /etc/skel || true
    umount /home/.skel || true
    rm -rf /etc/skel /home/.skel
    mkdir -p /etc/skel /home/.skel
    chmod 755 /etc/skel /home/.skel
    chown root:root /etc/skel /home/.skel
    # Add bind mount to /etc/fstab if not already there
    if ! grep -q "/home/.skel /etc/skel" /etc/fstab; then
      echo "/home/.skel /etc/skel none bind 0 0" >> /etc/fstab
    fi
    mount --bind /home/.skel /etc/skel
    systemctl start systemd-logind || true
  - |
    OS=$(go env GOOS); ARCH=$(go env GOARCH); curl -fsSL -o cmctl https://github.com/cert-manager/cmctl/releases/latest/download/cmctl_$${OS}_$${ARCH}
    chmod +x cmctl
    mv cmctl /usr/local/bin
  - |
    curl -fsSL -o /tmp/get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
    chmod 700 /tmp/get_helm.sh
    export HOME=/root && /tmp/get_helm.sh
    rm -f /tmp/get_helm.sh
    mkdir -p /root/.local/state/vs-kubernetes/tools/helm/linux-amd64
    ln -s /usr/local/bin/helm /root/.local/state/vs-kubernetes/tools/helm/linux-amd64/helm
  - |
    if git clone --recurse-submodules https://github.com/40docs/.github.git /root/40docs; then
      cd /root/40docs && [ -f ./install.sh ] && { chmod +x ./install.sh; ./install.sh; } || true
      cd -
    fi
  - |
    if [ ! -d /root/.tfenv ]; then
      git clone --depth=1 https://github.com/tfutils/tfenv.git /root/.tfenv && {
        chmod +x /root/.tfenv/bin/tfenv 2>/dev/null || true
        echo 'export PATH="$HOME/.tfenv/bin:$PATH"' >> /root/.bashrc
        echo 'export PATH="$HOME/.tfenv/bin:$PATH"' >> /root/.zshrc
        echo 'export PATH="$HOME/.tfenv/bin:$PATH"' >> /root/.profile
      }
    else
      cd /root/.tfenv && git pull -q 2>/dev/null || true && cd -
    fi
  - |
    if git clone https://github.com/40docs/dotfiles.git /root/dotfiles; then
      cd /root/dotfiles
      export DOTFILES_USER=root HOME=/root SKIP_TFENV_INSTALL=1
      [ -f ./install.sh ] && { chmod +x ./install.sh; bash install.sh --cloud-init; } || true
      cd -
    fi
  - |
    mkdir -p /root/.kube/
    echo "${var_kubeconfig}" | base64 -d > /root/.kube/config
    chmod 400 /root/.kube/config
    chmod 500 /root/.kube/
    echo 'export KUBECONFIG=$HOME/.kube/config' >> /root/.bashrc
    echo 'export KUBECONFIG=$HOME/.kube/config' >> /root/.profile
    echo 'export KUBECONFIG=$HOME/.kube/config' >> /root/.zshrc
  - useradd -D -s "$(which zsh)"
  - sed -i -E 's|^#?DSHELL=.*|DSHELL=/usr/bin/zsh|' /etc/adduser.conf
  - |
    echo 'ttf-mscorefonts-installer msttcorefonts/accepted-mscorefonts-eula select true' | debconf-set-selections
    DEBIAN_FRONTEND=noninteractive apt-get update -qq
    DEBIAN_FRONTEND=noninteractive apt-get full-upgrade -y
    DEBIAN_FRONTEND=noninteractive apt-get install -y ttf-mscorefonts-installer ubuntu-restricted-extras libavcodec-extra libavcodec-extra60 ubuntu-restricted-addons unrar
    dpkg --configure -a
    apt-get install -f -y
  - python3 -m pip install --break-system-packages --ignore-installed numpy>=2.0 uvicorn>=0.22 scipy>=1.12 aider-install azure-cognitiveservices-speech black checkov docs-chat-bot fastapi gitlint git-filter-repo google-api-python-client qrcode[pil] markitdown mkdocs-add-teaser mkdocs-awesome-pages-plugin mkdocs-childpages-card-grid-plugin mkdocs-enumerate-headings-plugin mkdocs-exclude mkdocs-git-authors-plugin mkdocs-git-committers-plugin-2 mkdocs-github-admonitions-plugin mkdocs-git-revision-date-localized-plugin mkdocs-glightbox mkdocs-literate-nav mkdocs-material 'mkdocs-material[imaging]' mkdocs-minify-plugin mkdocs-monorepo-plugin mkdocs-pdf-export-plugin mkdocs-same-dir mkdocs-section-index mkdocs-table-reader-plugin mkdocs-with-pdf 'mkdocstrings[crystal]' 'mkdocstrings[python]' oauth2client oterm pre-commit progressbar2 pydantic powerline-shell uv SuperClaude
  - |
    mkdir -p "/usr/share/fonts/powerline"
    curl -L https://github.com/powerline/powerline/raw/develop/font/PowerlineSymbols.otf -o /usr/share/fonts/powerline/PowerlineSymbols.otf
    mkdir -p /etc/fonts/conf.avail
    curl -L https://github.com/powerline/powerline/raw/develop/font/10-powerline-symbols.conf -o /etc/fonts/conf.avail/10-powerline-symbols.conf
    fc-cache -f /usr/share/fonts
  - |
    export HOME=/root
    if curl -s https://raw.githubusercontent.com/lacework/go-sdk/main/cli/install.sh | bash -s -- >/dev/null 2>&1; then
      echo 'source <(lacework completion bash)' >> /root/.bashrc
      echo 'export OLLAMA_API_BASE=http://127.0.0.1:11434' >> /root/.bashrc
      for COMP in sca iac remediate vuln-scanner; do
        lacework component install "$COMP" >/dev/null 2>&1 || true
      done
      mkdir -p /root/tmp && cd /root/tmp && lacework iac scan >/dev/null 2>&1 || true && cd -
    fi
  - curl -s https://raw.githubusercontent.com/terraform-linters/tflint/master/install_linux.sh | bash -s --
  - |
    export HOME=/root/.ollama
    if curl -fsSL https://ollama.com/install.sh | sh >/dev/null 2>&1; then
      systemctl start ollama.service && systemctl enable ollama.service
      for MODEL in deepseek-r1:latest gpt-oss:20b; do
        ollama pull "$MODEL" >/dev/null 2>&1 || true
      done
    fi
    echo 'export OLLAMA_API_BASE=http://127.0.0.1:11434' >> /root/.zshrc
    echo 'export OLLAMA_API_BASE=http://127.0.0.1:11434' >> /root/.bashrc
    echo 'export BRAVE_API_KEY="${var_brave_api_key}"' >> /root/.bashrc
    echo 'export BRAVE_API_KEY="${var_brave_api_key}"' >> /root/.zshrc
    echo 'export PERPLEXITY_API_KEY="${var_perplexity_api_key}"' >> /root/.bashrc
    echo 'export PERPLEXITY_API_KEY="${var_perplexity_api_key}"' >> /root/.zshrc
  - curl -s https://fluxcd.io/install.sh | bash -s --
  #- curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
  #- install -o root -g root -m 0755 kubectl /usr/bin/kubectl
  - |
    mkdir -p /root/.local/state/vs-kubernetes/tools/kubectl/
    ln -s `which kubectl` /root/.local/state/vs-kubernetes/tools/kubectl/kubectl
  - curl --proto '=https' --tlsv1.2 -sSf https://raw.githubusercontent.com/nektos/act/master/install.sh | bash -s -- -b /usr/local/bin
  - |
    curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "/tmp/awscliv2.zip"
    unzip -q /tmp/awscliv2.zip -d /tmp
    /tmp/aws/install
    rm -rf /tmp/aws /tmp/awscliv2.zip
  - ansible-galaxy collection install fortinet.console fortinet.fortiadc fortinet.fortianalyzer fortinet.fortiflexvm fortinet.fortimanager fortinet.fortios fortinet.fortiswitch fortinet.fortiweb
  - |
    export HOME=/root && /root/npm-install.sh || true
  - |
    export HOME="/root"
    dotnet tool install --global Microsoft.CST.DevSkim.CLI
    dotnet dev-certs https --trust
  - |
    IMAGES="ghcr.io/40docs/devcontainer:latest mcp/memory:latest mcp/git:latest mcp/time:latest mcp/sequentialthinking:latest mcp/filesystem:latest kubernetes-mcp-server:latest hashicorp/terraform-mcp-server:latest ghcr.io/github/github-mcp-server"
    for IMG in $IMAGES; do docker pull "$IMG" >/dev/null 2>&1 || true; done
    usermod -aG docker ${var_admin_username} || true
%{ if var_has_gpu }
  - |
    # Enable NVIDIA persistence daemon for stable GPU memory management
    nvidia-persistenced --user ${var_admin_username}
    systemctl enable nvidia-persistenced
    # Set GPU performance mode
    nvidia-smi -pm ENABLED || echo "Performance mode setting may need manual intervention"
    # Configure NVIDIA Container Runtime for Docker
    nvidia-ctk runtime configure --runtime=docker
    systemctl restart docker
    # Wait for Docker to fully restart and recognize nvidia runtime
    sleep 10
    # Add user to render group for GPU device access
    usermod -aG render ${var_admin_username}
    # Set up udev rules for GPU device permissions
    echo 'KERNEL=="nvidia*", GROUP="render", MODE="0666"' > /etc/udev/rules.d/70-nvidia.rules
    echo 'KERNEL=="nvidia_uvm", GROUP="render", MODE="0666"' >> /etc/udev/rules.d/70-nvidia.rules
    echo 'KERNEL=="nvidia_modeset", GROUP="render", MODE="0666"' >> /etc/udev/rules.d/70-nvidia.rules
    echo 'KERNEL=="nvidiactl", GROUP="render", MODE="0666"' >> /etc/udev/rules.d/70-nvidia.rules
    udevadm control --reload-rules
    udevadm trigger
    # Verify GPU setup
    nvidia-smi || echo "GPU setup may need manual intervention"
    # Test docker nvidia runtime after ensuring it's available
    if docker info | grep -q nvidia; then
      docker run --rm --gpus all ubuntu nvidia-smi || echo "GPU Docker runtime test failed, may need manual intervention"
    else
      echo "NVIDIA runtime not available in Docker, skipping GPU container test"
    fi
%{ endif }
  - "service apache2 stop && systemctl disable apache2"
  - "export HOME=/root && curl -fsSL https://coder.com/install.sh | sh -s -- && usermod -aG docker coder && echo 'CODER_HTTP_ADDRESS=0.0.0.0:80' > /etc/coder.d/coder.env && systemctl enable --now coder && journalctl -u coder.service -b && rm -rf /root/.cache/coder/"
  - |
    #!/bin/sh
    ARCH=$(dpkg-architecture -q DEB_BUILD_ARCH)
    download_url=$(curl --silent "https://api.github.com/repos/jgraph/drawio-desktop/releases/latest" \
      | jq -r --arg ARCH "$ARCH" \
          '.assets[] | select(.name | contains("deb") and contains($ARCH)) | .browser_download_url')
    curl -s -L "$${download_url}" -o /tmp/drawio.deb
    dpkg -i /tmp/drawio.deb
    rm /tmp/drawio.deb
  - |
    curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube_latest_amd64.deb
    dpkg -i minikube_latest_amd64.deb
    mkdir -p /root/.local/state/vs-kubernetes/tools/minikube/linux-amd64
    ln -s /usr/bin/minikube /root/.local/state/vs-kubernetes/tools/minikube/linux-amd64/minikube
    rm minikube_latest_amd64.deb
  - |
    curl -Lo /tmp/actionlint.sh https://raw.githubusercontent.com/rhysd/actionlint/main/scripts/download-actionlint.bash
    chmod 755 /tmp/actionlint.sh
    export HOME=/root && bash /tmp/actionlint.sh latest /usr/bin
    rm /tmp/actionlint.sh
  - |
    curl -sSLo /tmp/terraform-docs.tar.gz \
      https://github.com/terraform-docs/terraform-docs/releases/download/v0.20.0/terraform-docs-v0.20.0-linux-amd64.tar.gz
    tar --extract --gzip --file /tmp/terraform-docs.tar.gz \
        --directory /usr/local/bin terraform-docs
    chmod +x /usr/local/bin/terraform-docs
    rm -f /tmp/terraform-docs.tar.gz
  - |
    curl -Lo /tmp/terrascan.tar.gz https://github.com/tenable/terrascan/releases/download/v1.19.9/terrascan_1.19.9_Linux_x86_64.tar.gz
    tar -xf /tmp/terrascan.tar.gz terrascan
    install terrascan /usr/local/bin
    rm -rf /tmp/terrascan.tar.gz terrascan
  - |
    LAZYGIT_VERSION=$(curl -s "https://api.github.com/repos/jesseduffield/lazygit/releases/latest" | \grep -Po '"tag_name": *"v\K[^"]*')
    curl -Lo /tmp/lazygit.tar.gz "https://github.com/jesseduffield/lazygit/releases/download/v$${LAZYGIT_VERSION}/lazygit_$${LAZYGIT_VERSION}_Linux_x86_64.tar.gz"
    tar xf /tmp/lazygit.tar.gz lazygit
    install lazygit -D -t /usr/local/bin/
    rm -rf /tmp/lazygit.tar.gz lazygit
  - curl -fsSL https://raw.githubusercontent.com/infracost/infracost/master/scripts/install.sh | sh
  - |
    curl -Lo /tmp/kustomize.sh "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh"
    chmod 755 /tmp/kustomize.sh
    export HOME=/root && bash /tmp/kustomize.sh /usr/local/bin
    rm /tmp/kustomize.sh
  - |
    curl -sSLo /tmp/speedtest.tgz \
      https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-linux-x86_64.tgz
    tar --extract --gzip --file /tmp/speedtest.tgz \
        --directory /usr/local/bin speedtest
    chmod +x /usr/local/bin/speedtest
    rm -f /tmp/speedtest.tgz
    echo 'alias speedtest="speedtest --accept-license --accept-gdpr"' >> /root/.bash_aliases
    echo 'alias speedtest="speedtest --accept-license --accept-gdpr"' >> /root/.zshrc
    echo 'alias speedtest="speedtest --accept-license --accept-gdpr"' >> /root/.bashrc
  - |
    #!/bin/sh
    export PROVIDER=all
    curl -LO "https://github.com/GoogleCloudPlatform/terraformer/releases/download/$(curl -s https://api.github.com/repos/GoogleCloudPlatform/terraformer/releases/latest | grep tag_name | cut -d '"' -f 4)/terraformer-$${PROVIDER}-linux-amd64"
    chmod +x terraformer-$${PROVIDER}-linux-amd64
    mv terraformer-$${PROVIDER}-linux-amd64 /usr/local/bin/terraformer
  - |
    export "GOBIN=/usr/local/bin"
    go install github.com/Azure/aztfexport@latest
    go install golang.org/x/tools/gopls@latest
    go install honnef.co/go/tools/cmd/staticcheck@latest
  - |
    # Clone and build xmrig with proper dependency checks
    if command -v cmake >/dev/null 2>&1 && command -v make >/dev/null 2>&1; then
      git clone https://github.com/xmrig/xmrig.git /root/xmrig
      mkdir -p /root/xmrig/build && cd /root/xmrig/build
      cmake .. && make -j$(nproc) && install -m 0755 xmrig /usr/local/bin/xmrig || true
      cd -
      rm -rf /root/xmrig
    else
      echo "Warning: cmake or make not available, skipping xmrig build"
    fi
  - update-alternatives --set editor /usr/bin/vim.basic
  - |
    LACEWORK_VERSION=$(curl -s "https://api.github.com/repos/robinmordasiewicz/extensible-reporting/releases/latest" | grep -Po '"tag_name": "v\K[^"]*')
    curl -L -o lw_report_gen "https://github.com/robinmordasiewicz/extensible-reporting/releases/download/v$${LACEWORK_VERSION}/lw_report_gen_linux_x86_64"
    install lw_report_gen /usr/local/bin
    rm lw_report_gen
  - curl -s https://ohmyposh.dev/install.sh | HOME=/root bash -s -- -d /usr/local/bin -t /var/local/themes
  - |
    export HOME=/root
    curl -fsSL https://claude.ai/install.sh | bash -s --
    CLAUDE_LINK="/root/.local/bin/claude"
    CLAUDE_TARGET=$(readlink "$CLAUDE_LINK" || true)
    if [ -n "$CLAUDE_TARGET" ] && [ -e "$CLAUDE_TARGET" ]; then
      REL_TARGET=$(realpath --relative-to="$(dirname "$CLAUDE_LINK")" "$CLAUDE_TARGET")
      ln -sf "$REL_TARGET" "$CLAUDE_LINK"
    fi
    echo "export ENABLE_BACKGROUND_TASKS=1" >> /root/.bashrc
    echo "export ENABLE_BACKGROUND_TASKS=1" >> /root/.zshrc
  - curl -fsSL https://raw.githubusercontent.com/smtg-ai/claude-squad/main/install.sh | HOME=/root bash -s --
  - |
    echo "[$(date)] Starting Claude CLI symlink setup..." | tee -a /var/log/cloud-init-output.log
    export HOME=/root PATH="/root/.local/bin:$PATH"

    if command -v claude >/dev/null 2>&1; then
        echo "[$(date)] Found claude command, creating symlink..." | tee -a /var/log/cloud-init-output.log
        CLAUDE_PATH=$(which claude)
        CLAUDE_DIR=$(dirname "$CLAUDE_PATH")
        ln -sf "$CLAUDE_PATH" "$CLAUDE_DIR/claude_cli"
        export PATH="$CLAUDE_DIR:$PATH"
        echo "[$(date)] Claude symlink created successfully" | tee -a /var/log/cloud-init-output.log
    elif [ -f "/root/.local/bin/claude" ]; then
        echo "[$(date)] Found claude binary, creating local symlink..." | tee -a /var/log/cloud-init-output.log
        ln -sf "/root/.local/bin/claude" "/root/.local/bin/claude_cli"
        export PATH="/root/.local/bin:$PATH"
        echo "[$(date)] Local claude symlink created successfully" | tee -a /var/log/cloud-init-output.log
    else
        echo "[$(date)] WARNING: Claude command not found" | tee -a /var/log/cloud-init-output.log
    fi

    echo "[$(date)] Checking for SuperClaude..." | tee -a /var/log/cloud-init-output.log
    if command -v SuperClaude >/dev/null 2>&1; then
        echo "[$(date)] SuperClaude found, attempting installation with timeout..." | tee -a /var/log/cloud-init-output.log
        timeout 300 bash -c 'printf "y\ny\n" | SuperClaude install --profile developer' >/dev/null 2>&1 || echo "[$(date)] SuperClaude installation failed or timed out" | tee -a /var/log/cloud-init-output.log
        echo "[$(date)] SuperClaude installation attempt completed" | tee -a /var/log/cloud-init-output.log
    else
        echo "[$(date)] SuperClaude not found, skipping installation" | tee -a /var/log/cloud-init-output.log
    fi
    echo "[$(date)] Claude CLI setup section completed" | tee -a /var/log/cloud-init-output.log
  - |
    echo "[$(date)] Starting VS Code tunnel setup..." | tee -a /var/log/cloud-init-output.log
    mkdir -p /root/.config/systemd/user

    # Create a user systemd service that starts the tunnel on login
    cat << 'EOF' > /root/.config/systemd/user/vscode-tunnel.service
    [Unit]
    Description=VS Code Remote Tunnel
    After=network.target

    [Service]
    ExecStart=%h/bin/start-tunnel.sh
    Restart=always
    TimeoutStartSec=10

    [Install]
    WantedBy=default.target
    EOF

    mkdir -p /root/bin
    cat << 'EOF' > /root/bin/start-tunnel.sh
    #!/bin/bash
    export PATH=$PATH:/usr/local/bin
    export HOME=$HOME
    exec code tunnel --accept-server-license-terms --name=$(hostname)-$USER
    EOF
    chmod +x /root/bin/start-tunnel.sh
    echo "[$(date)] VS Code tunnel setup completed" | tee -a /var/log/cloud-init-output.log
  - |
    echo "[$(date)] Starting cache pre-warming..." | tee -a /var/log/cloud-init-output.log
    bash /root/prewarm-cache.sh || echo "[$(date)] Cache pre-warming failed or completed with errors" | tee -a /var/log/cloud-init-output.log
    echo "[$(date)] Cache pre-warming completed" | tee -a /var/log/cloud-init-output.log
  - touch /root/.hushlogin
  - |
    echo "[$(date)] Starting skeleton directory setup..." | tee -a /var/log/cloud-init-output.log
    cp -a /root/.act /etc/skel
    cp -a /root/.aspnet /etc/skel
    cp -a /root/.azure /etc/skel
    cp -a /root/.bash_aliases /etc/skel
    cp -a /root/.bashrc /etc/skel
    cp -a /root/.cache /etc/skel
    cp -a /root/.config /etc/skel
    mkdir -p /root/.claude
    if [ -f /root/.claude/mcp.json ]; then
      jq '.mcpServers.Perplexity.env.PERPLEXITY_API_KEY = "${var_perplexity_api_key}"' /root/.claude/mcp.json > /tmp/mcp.json && mv /tmp/mcp.json /root/.claude/mcp.json
      jq '.mcpServers["brave-search"].env.BRAVE_API_KEY = "${var_brave_api_key}"' /root/.claude/mcp.json > /tmp/mcp.json && mv /tmp/mcp.json /root/.claude/mcp.json
    fi
    cp -a /root/.claude /etc/skel
    cp -a /root/.claude.json /etc/skel
    cp -a /root/.digrc /etc/skel
    cp -a /root/.dotnet /etc/skel
    cp -a /root/.gitconfig /etc/skel
    cp -a /root/.hushlogin /etc/skel
    cp -a /root/.kube /etc/skel
    cp -a /root/.lacework.toml /etc/skel
    cp -a /root/.launchpadlib /etc/skel
    cp -a /root/.local /etc/skel
    cp -a /root/.npm /etc/skel
    cp -a /root/.npmrc /etc/skel
    cp -a /root/.nuget /etc/skel
    cp -a /root/.oh-my-posh /etc/skel
    cp -a /root/.oh-my-zsh /etc/skel
    cp -a /root/.opencommit /etc/skel
    cp -a /root/.p10k.zsh /etc/skel
    cp -a /root/.profile /etc/skel
    cp -a /root/.terraform.d /etc/skel
    cp -a /root/.tfenv /etc/skel
    cp -a /root/.tmux /etc/skel
    cp -a /root/.tmux.conf /etc/skel
    cp -a /root/.vim /etc/skel
    cp -a /root/.vimrc /etc/skel
    cp -a /root/.vscode /etc/skel
    cp -a /root/.vscode-insiders /etc/skel
    cp -a /root/.vscode-server /etc/skel
    cp -a /root/.vscode-server-insiders /etc/skel
    cp -a /root/.wget-hsts /etc/skel
    cp -a /root/.z /etc/skel
    cp -a /root/.zshrc /etc/skel
    cp -a /root/dotfiles /etc/skel
    cp -a /root/40docs /etc/skel
    cp -a /root/go /etc/skel
    cp -a /root/bin /etc/skel
    cp -a /root/snap /etc/skel
    echo "[$(date)] Skeleton directory setup completed" | tee -a /var/log/cloud-init-output.log
  - |
    echo "[$(date)] Starting GitHub Action runner installation..." | tee -a /var/log/cloud-init-output.log
    timeout 600 bash -c '/root/install-github-action-runner.sh' || echo "[$(date)] GitHub runner installation failed or timed out" | tee -a /var/log/cloud-init-output.log
    echo "[$(date)] GitHub Action runner installation completed" | tee -a /var/log/cloud-init-output.log
  - |
    echo "[$(date)] Starting firmware updates..." | tee -a /var/log/cloud-init-output.log
    fwupdmgr update -y --no-reboot-check || echo "[$(date)] Firmware updates completed with errors or no updates available" | tee -a /var/log/cloud-init-output.log
    echo "[$(date)] Firmware updates completed" | tee -a /var/log/cloud-init-output.log
  - |
    echo "[$(date)] Checking for reboot requirement..." | tee -a /var/log/cloud-init-output.log
    [ -f /var/run/reboot-required ] && echo "[$(date)] Reboot required, initiating reboot..." | tee -a /var/log/cloud-init-output.log && reboot || echo "[$(date)] No reboot required, cloud-init runcmd completed successfully" | tee -a /var/log/cloud-init-output.log
